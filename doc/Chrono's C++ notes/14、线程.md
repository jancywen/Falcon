在 C++ 语言里，线程就是一个能够独立运行的函数。

任何程序一开始就有一个主线程，它从 main() 开始运行。主线程可以调用接口函数，创建出子线程。子线程会立即脱离主线程的控制流程，单独运行，但共享主线程的数据。程序创建出多个子线程，执行多个不同的函数，也就成了多线程。


**“读而不写”就不会有数据竞争** 所以，在 C++ 多线程编程里读取 const 变量总是安全的，对类调用 const 成员函数、对容器调用只读算法也总是线程安全的。



### 多线程开发实践

在 C++ 里，有四个基本的工具：仅调用一次、线程局部存储、原子变量和线程对象。

#### 1、仅调用一次

call_once()


```C++
static std::once_flag flag; // 全局的初始化标志
// 在线程里运行的lambda表达式
auto f = []()
{ 
    std::call_once(flag, // 仅一次调用，注意要传flag 
        [](){ // 匿名lambda，初始化函数，只会执行一次 
            cout << "only once" << endl; 
        } // 匿名lambda结束 
    ); // 在线程里运行的lambda表达式结束
};
    thread t1(f); // 启动两个线程，运行函数f
    thread t2(f);
```

#### 2、线程局部存储

thread_local

有 thread_local 标记的变量在每个线程里都会有一个独立的副本，是“线程独占”的，所以就不会有竞争读写的问题


#### 3、原子变量

要想保证多线程读写共享数据的一致性，关键是要**解决同步问题**

目前，C++ 只能让一些最基本的类型原子化，比如 atomic_int、atomic_long，等等

**原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号**

```C++ 
atomic_int x {0}; // 初始化，不能用=
atomic_long y {1000L}; // 初始化，只能用圆括号或者花括号
```

最基本的用法是把原子变量当作线程安全的全局计数器或者标志位，这也算是“初心”吧。但它还有一个更重要的应用领域，就是实现高效的无锁数据结构（lock-free）不要自己写，推荐 boost.lock_free

#### 4、线程

async()  **异步运行** 一个任务， 相当于开了一个线程
