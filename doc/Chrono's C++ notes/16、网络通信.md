
### 1.libcurl

安装：

1、先到 https://curl.haxx.se/ 上下载最新的curl源码

2、终端：进入解压后的curl目录

3、终端：./configure --prefix=/usr/local/curl (设置安装路径)

4、终端：make (编译)

5、终端：make install (安装)

6、最后会在/usr/local目录生成一个curl目录，说明安装成功。


注意：如果执行安装操作之后在指定目录没有生成curl文件夹，请检查一下你设置的目录是不是有权限限制，然后加上sudo命令(sudo make install)重新安装一遍。


应用：

> 使用 curl_easy_init() 创建一个句柄，类型是 CURL*。但我们完全没有必要关心句柄的类型，直接用 auto 推导就行。

> 使用 curl_easy_setopt() 设置请求的各种参数，比如请求方法、URL、header/body 数据、超时、回调函数等。这是最关键的操作。

> 使用 curl_easy_perform() 发送数据，返回的数据会由回调函数处理。

> 使用 curl_easy_cleanup() 清理句柄相关的资源，结束会话。


### cpr 
安装不了，，，，也是郁闷呀


### ZMQ  

安装 libzmq  4.3.3
```shell
brew install zeromq
```

cppzmq  依赖 libzmq


ZMQ的两个基础类：

* context_t，它是 ZMQ 的运行环境。

* socket_t，表示 ZMQ 的套接字，需要指定工作模式。

ZeroMQ套接字是异步的

#### bind、connect

服务器使用Bind而客户端使用Connect。

ZeroMQ为每个基础连接创建队列。使用 **bind**，您可以允许对等方连接到您，因此您不知道将来会有多少个对等方，因此您无法提前创建队列。而是在各个对等方连接到绑定的套接字时创建队列。借助**Connect**，ZeroMQ知道将至​​少有一个对等端，因此它可以立即创建一个队列。这适用于ROUTER除外的所有套接字类型，在ROUTER中，仅在我们连接的对等方确认我们的连接之后才创建队列。



#### 工作模式：

* **Request-reply**，它将一组客户端连接到一组服务。这是一个远程过程调用和任务分配模式。

请求-应答模式旨在用于各种面向服务的体系结构。它有两种基本类型：同步（REQ和REP 套接字类型）和异步套接字类型（DEALER和ROUTER套接字类型），它们可以以多种方式混合。

* **Pub-sub**，它将一组发布者连接到一组订阅者。这是一种数据分发模式。

发布-订阅模式用于以扇出方式将数据从单个发布者一对多分发到多个订阅者。

PUB：仅发布

SUB：仅接收

XPUB：以传入消息的形式接收来自对等方的订阅。

XSUB：通过向套接字发送订阅消息来进行订阅。

* **Pipeline**，以扇出/扇入模式连接节点，该模式可以具有多个步骤和循环。这是并行的任务分配和收集模式。

流水线模式用于任务分配，通常在多级流水线中，其中一个或几个节点将工作推给许多工作人员，然后依次将结果推向一个或几个收集器。该模式在大多数情况下是可靠的，因为除非节点意外断开连接，否则它不会丢弃消息。它具有可伸缩性，因为节点可以随时加入。

PUSH

PULL

* **Exclusive pair**，专门连接两个套接字。这是在一个进程中连接两个线程的一种模式，不要与“普通”套接字对混淆。

PAIR

ZMQ 的套接字：

* TCP 通信地址的形式是“tcp://…”，指定 IP 地址和端口号；

* 进程内通信地址的形式是“inproc://…”，指定一个本地可访问的路径；

* 进程间通信地址的形式是“ipc://…”，也是一个本地可访问的路径。

用 bind()/connect() 这两个函数把 ZMQ 套接字连接起来之后，就可以用 send()/recv() 来收发数据了

[ZeroMQ Socket API](https://zeromq.org/socket-api/)