### 预处理编程

**预处理阶段编程的操作目标是“源码”，用各种指令控制预处理器，把源码改造成另一种形式，就像是捏橡皮一样**

预处理指令都以符号 “#”开头，它不属于C++ 语言，它走的是预处理器，不受C++语法规则的约束。

预处理指令永远是 **顶格写**

单独的一个“#”也是一个预处理指令，叫“**空指令**”，可以当作特别的预处理空行。而“#”与后面的指令之间也可以有空格，从而实现缩进，方便排版。


    #                              // 预处理空行
    #if __linux__                  // 预处理检查宏是否存在
    #   define HAS_LINUX    1      // 宏定义，有缩进
    #endif                         // 预处理条件语句结束
    #                              // 预处理空行

可以让 GCC 使用“-E”选项输出预处理后的源码

    g++ test03.cpp -E -o a.cxx    #输出预处理后的源码


总结：**# 开头、顶格写**

### 包含文件（#include）

作用是“**包含文件**”，**可以包含任意的文件**（源码、普通文本，甚至是图片、音频、视频）。

“#include”其实是非常“弱”的，不做什么检查，就是“死脑筋”把**数据合并进源文件**。


**Include Guard**

作用：防止代码被重复包含 

样式： #ifndef/#define/#endif


    #ifndef _XXX_H_INCLUDED_
    #define _XXX_H_INCLUDED_

    ...    // 头文件内容

    #endif // _XXX_H_INCLUDED_


还可以编写一些代码片段，存进“*.inc”文件里，然后有选择地加载，用得好的话，可以实现“源码级别的抽象”。

    static uint32_t  calc_table[] = {
    #  include "calc_values.inc"        // 非常大的一个数组，细节被隐藏
    };

calc_values.inc
    
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, ...


补充：

> #include< file >编译程序会先到标准函数库中找文件
> #include”file” 编译程序会先从当前目录中找文件


### 宏定义（#define/#undef）

定义一个源码级别的“**文本替换**”

“#define”可谓“无所不能”，在预处理阶段可以无视 C++ 语法限制，替换任何文字，定义常量 / 变量，实现函数功能，为类型起别名（typedef），减少重复代码……

**使用宏的时候一定要谨慎，时刻记着以简化代码、清晰易懂为目标，不要“滥用”，避免导致源码混乱不堪，降低可读性。**

宏的展开、替换发生在预处理阶段，不涉及函数调用、参数传递、指针寻址，没有任何运行期的效率损失，所以对于一些调用频繁的小代码片段来说，用宏来封装的效果比 inline 关键字要更好，因为它真的是源码级别的无条件内联。

**宏是没有作用域概念的，永远是全局生效**。所以，对于一些用来简化代码、起临时作用的宏，最好是用完后尽快用“#undef”取消定义，避免冲突的风险。


    #define CUBE(a) (a) * (a) * (a)  // 定义一个简单的求立方的宏

    cout << CUBE(10) << endl;        // 使用宏简化代码

    #undef CUBE                      // 使用完毕后立即取消定义  


还可以**宏定义前先检查**，如果之前有定义就先 undef，然后再重新定义


    #ifdef AUTH_PWD                  // 检查是否已经有宏定义
    #  undef AUTH_PWD                // 取消宏定义
    #endif                           // 宏定义检查结束
    #define AUTH_PWD "xxx"           // 重新宏定义

### 条件编译（#if/#else/#endif）

通过判断宏的数值来产生不同的源码，改变源文件的形态，在预处理阶段实现分支处理。

两个要点，一个是条件指令“#if”，另一个是后面的“判断依据”

查看底层系统信息

    g++ -E -dM - < /dev/null