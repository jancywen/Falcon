
### 迭代器

算法只能通过迭代器去“**间接**”访问容器以及元素，算法的能力是由迭代器决定的。

这种间接的方式有什么好处呢？

这就是泛型编程的理念，与面向对象正好相反，分离了数据和操作。算法可以不关心容器的内部结构，以一致的方式去操作元素，适用范围更广，用起来也更灵活。


**迭代器** 简单地理解为另一种形式的“智能指针”，只是它**强调的是对数据的访问**，而不是生命周期管理。

容器一般都会提供 begin()、end() 成员函数，调用它们就可以得到表示两个端点的迭代器，具体类型最好用 auto 自动推导，也可使用全局函数 begin()、end()（另外还有 cbegin()、cend() 函数，返回的是常量迭代器）

常用操作

* distance()，计算两个迭代器之间的距离；

* advance()，前进或者后退 N 步；

* next()/prev()，计算迭代器前后的某个位置。


### for_each

for_each 算法的价值就体现在这里，它把要做的事情分成了两部分，也就是两个函数：一个**遍历容器元素**，另一个**操纵容器元素**，而且名字的含义更明确，代码也有更好的封装。

```c++
for_each(                   // for_each算法，内部定义lambda表达式 
    cbegin(v), cend(v),     // 获取常量迭代器 
    [](const auto& x)       // 匿名lambda表达式 
    { 
        cout << x << ","; 
    });
```

### 排序算法

1. sort() 快排算法 全排

2. 要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的；

3. 选出前几名（TopN），应该用 partial_sort；

4. 选出前几名，但不要求再排出名次（BestN），应该用 nth_element；

5. 中位数（Median）、百分位数（Percentile），还是用 nth_element；

6. 按照某种规则把元素划分成两组，用 partition；

7. 第一名和最后一名，用 minmax_element。



### 查找算法

1. binary_search 二分查找 返回一个bool值

2. lower_bound 返回第一个“**大于或等于**”值的位置 返回值是一个迭代器

3. upper_bound，返回的是第一个“**大于**”值的元素。

4. find 