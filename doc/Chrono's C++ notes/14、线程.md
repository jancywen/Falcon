在 C++ 语言里，线程就是一个能够独立运行的函数。

任何程序一开始就有一个主线程，它从 main() 开始运行。主线程可以调用接口函数，创建出子线程。子线程会立即脱离主线程的控制流程，单独运行，但共享主线程的数据。程序创建出多个子线程，执行多个不同的函数，也就成了多线程。


**“读而不写”就不会有数据竞争** 所以，在 C++ 多线程编程里读取 const 变量总是安全的，对类调用 const 成员函数、对容器调用只读算法也总是线程安全的。



### 多线程开发实践

在 C++ 里，有四个基本的工具：仅调用一次、线程局部存储、原子变量和线程对象。

#### 1、仅调用一次

call_once()


```C++
static std::once_flag flag; // 全局的初始化标志
// 在线程里运行的lambda表达式
auto f = []()
{ 
    std::call_once(flag, // 仅一次调用，注意要传flag 
        [](){ // 匿名lambda，初始化函数，只会执行一次 
            cout << "only once" << endl; 
        } // 匿名lambda结束 
    ); // 在线程里运行的lambda表达式结束
};
    thread t1(f); // 启动两个线程，运行函数f
    thread t2(f);
```

#### 2、线程局部存储

thread_local

有 thread_local 标记的变量在每个线程里都会有一个独立的副本，是“线程独占”的，所以就不会有竞争读写的问题


#### 3、原子变量

要想保证多线程读写共享数据的一致性，关键是要**解决同步问题**

目前，C++ 只能让一些最基本的类型原子化，比如 atomic_int、atomic_long，等等

**原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号**

```C++ 
atomic_int x {0}; // 初始化，不能用=
atomic_long y {1000L}; // 初始化，只能用圆括号或者花括号
```

最基本的用法是把原子变量当作线程安全的全局计数器或者标志位，这也算是“初心”吧。但它还有一个更重要的应用领域，就是实现高效的无锁数据结构（lock-free）不要自己写，推荐 boost.lock_free

#### 4、线程

async()  **异步运行** 一个任务， 隐含的动作是启动一个线程去执行，但不绝对保证立即启动（也可以在第一个参数传递 std::launch::async，要求立即启动线程）。

异步并发多个任务，让底层去自动管理线程

async() 会返回一个 future 变量，可以认为是代表了执行结果的“期货”，如果任务有返回值，就可以用成员函数 get() 获取。

不过要特别注意，get() 只能调一次，再次获取结果会发生错误，抛出异常 std::future_error。

如果你不显式获取 async() 的返回值（即 future 对象），它就会**同步阻塞**直至任务完成（由于临时对象的析构函数），于是“async”就变成了“sync”。

```C++

auto task = [](auto x)                  // 在线程里运行的lambda表达式
{
    this_thread::sleep_for( x * 1ms);  // 线程睡眠
    cout << "sleep for " << x << endl;
    return x;
};

auto f = std::async(task, 10);         // 启动一个异步任务
f.wait();                              // 等待任务完成

assert(f.valid());                    // 确实已经完成了任务
cout << f.get() << endl;              // 获取任务的执行结果
```