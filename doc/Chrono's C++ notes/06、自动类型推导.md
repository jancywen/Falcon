“自动类型推导”是给编译器下的指令，让编译器去计算表达式的类型，然后返回给程序员。

### auto

 * auto 的“自动推导”能力只能用在“**初始化**”的场合.

 > 就是赋值初始化或者花括号初始化（初始化列表、Initializer list），变量**右边**必须要有一个表达式（简单、复杂都可以）。这样你才能在左边放上 auto，编译器才能找到表达式，帮你自动计算类型。

```C++
auto x = 0L; // 自动推导为long
```

 * 在类成员变量初始化的时候,不允许使用 auto 推导类型

#### * auto 总是推导出“值类型”，绝不会是“引用”；

#### * auto 可以附加上 const、volatile、*、& 这样的类型修饰符，得到新的类型。

### decltype

1. 与 auto 相比
> 1.把表达式改到左边
> 2.decltype 不仅能够推导出值类型，还能够推导出**引用类型**，也就是表达式的“原始类型”。

auto和decltype的编译期计算类型过程是一样的，都是得出类型，不会计算表达式，只是一个从初始化里获取表达式，一个自带表达式

```C++
int x = 0;          // 整型变量

decltype(x)     x1;      // 推导为int，x1是int
decltype(x)&    x2 = x;    // 推导为int，x2是int&，引用必须赋值
decltype(x)*    x3;      // 推导为int，x3是int*
decltype(&x)    x4;      // 推导为int*，x4是int*
decltype(&x)*   x5;      // 推导为int*，x5是int**
decltype(x2)    x6 = x2;  // 推导为int&，x6是int&，引用必须赋值
```

完全可以把 decltype 看成是一个真正的类型名，用在变量声明、函数参数 / 返回值、模板参数等任何类型能出现的地方，只不过这个类型是在编译阶段通过表达式“计算”得到的。


C++一个比较奇怪的语法，x是值类型，加上括号就变成了引用类型

    decltype(auto) x1 = (x); // 推导为int&，因为(expr)是引用类型。


### auto/decltype 应用

1. 在变量声明时应该尽量多用 auto 
2. auto的最佳实践 range-based for 容器元素类型、迭代器返回值和首末位置
3. 推导函数返回值用 auto
4. decltype 是 auto 的高级形式，更侧重于编译阶段的类型计算，所以常用在泛型编程里，获取各种类型，配合 typedef 或者 using 会更加方便。当你感觉“这里我需要一个特殊类型”的时候，选它就对了。